// Attendance related models

model Attendance {
  id                String    @id @default(uuid())
  employeeId        String
  employee          Employee  @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  date              DateTime // Date of attendance (without time)
  checkIn           DateTime? // Check-in time
  checkOut          DateTime? // Check-out time
  status            String    @default("present") // present, absent, late, half-day, short-day, on-leave, holiday
  isRemote          Boolean   @default(false) // Remote attendance flag
  location          String? // Location/address for check-in (for remote attendance)
  latitude          Decimal? // GPS latitude
  longitude         Decimal? // GPS longitude
  workingHours      Decimal? // Calculated working hours in decimal format
  overtimeHours     Decimal? // Overtime hours
  lateMinutes       Int? // Late arrival in minutes
  earlyLeaveMinutes Int? // Early leave in minutes
  breakDuration     Int? // Break duration in minutes
  notes             String? // Additional notes or comments
  approvedBy        String? // User ID who approved this attendance
  approvedAt        DateTime? // Approval timestamp
  createdById       String?
  createdBy         User?     @relation("AttendanceCreatedBy", fields: [createdById], references: [id])
  updatedById       String?
  updatedBy         User?     @relation("AttendanceUpdatedBy", fields: [updatedById], references: [id])
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@unique([employeeId, date]) // One attendance record per employee per day (creates index automatically)
}

model AttendanceRequestQuery {
  id                  String    @id @default(uuid())
  employeeId          String?
  employee            Employee? @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  employeeName        String?
  department          String?
  subDepartment       String?
  attendanceDate      DateTime
  clockInTimeRequest  String?
  clockOutTimeRequest String?
  breakIn             String?
  breakOut            String?
  query               String
  approvalStatus      String    @default("pending")
  approvedBy          String?
  approvedAt          DateTime?
  rejectionReason     String?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@index([employeeId])
  @@index([approvalStatus])
  @@index([attendanceDate])
}

model LeaveApplication {
  id                  String    @id @default(uuid())
  employeeId          String
  employee            Employee  @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  leaveTypeId         String
  leaveType           LeaveType @relation(fields: [leaveTypeId], references: [id], onDelete: Restrict)
  dayType             String    @default("fullDay") // fullDay, halfDay, shortLeave
  fromDate            DateTime
  toDate              DateTime
  reasonForLeave      String
  addressWhileOnLeave String
  status              String    @default("pending") // pending, approved, rejected
  approval1           String? // User ID of first approver
  approval1Status     String? // pending, approved, rejected
  approval1Date       DateTime?
  approval2           String? // User ID of second approver (if needed)
  approval2Status     String? // pending, approved, rejected
  approval2Date       DateTime?
  remarks             String?
  createdById         String?
  createdBy           User?     @relation("LeaveApplicationCreatedBy", fields: [createdById], references: [id])
  updatedById         String?
  updatedBy           User?     @relation("LeaveApplicationUpdatedBy", fields: [updatedById], references: [id])
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@index([employeeId])
  @@index([leaveTypeId])
  @@index([status])
  @@index([fromDate])
  @@index([toDate])
}

model AttendanceExemption {
  id                String    @id @default(uuid())
  employeeId        String?
  employee          Employee? @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  employeeName      String?
  department        String?
  subDepartment     String?
  attendanceDate    DateTime
  flagType          String // Late, Absent, Early Leave, Missing Check-in, Missing Check-out, Other
  exemptionType     String // Medical Emergency, Family Emergency, Official Duty, Approved Leave, System Error, Other
  reason            String
  approvalStatus    String    @default("pending") // pending, approved, rejected
  approvedBy        String?
  approvedAt        DateTime?
  rejectionReason   String?
  createdById       String?
  createdBy         User?     @relation("AttendanceExemptionCreatedBy", fields: [createdById], references: [id])
  updatedById       String?
  updatedBy         User?     @relation("AttendanceExemptionUpdatedBy", fields: [updatedById], references: [id])
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([employeeId])
  @@index([approvalStatus])
  @@index([attendanceDate])
}

// Date-based working hours policy assignments
model WorkingHoursPolicyAssignment {
  id                    String             @id @default(uuid())
  employeeId            String
  employee              Employee           @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  workingHoursPolicyId  String
  workingHoursPolicy    WorkingHoursPolicy @relation(fields: [workingHoursPolicyId], references: [id], onDelete: Restrict)
  startDate             DateTime           // Start date of policy assignment
  endDate               DateTime           // End date of policy assignment (can be same as startDate for single day)
  notes                 String?            // Optional notes for this assignment
  createdById           String?
  createdBy             User?              @relation("PolicyAssignmentCreatedBy", fields: [createdById], references: [id])
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt

  @@index([employeeId])
  @@index([workingHoursPolicyId])
  @@index([startDate])
  @@index([endDate])
}